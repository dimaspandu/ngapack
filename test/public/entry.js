(function(GlobalConstructor,global,modules,entry){var __modules__={};var __modulePointer__={};var __asyncModulePointer__={};(function(global){if(typeof global.CSSStyleSheet==="function"&&"replaceSync"in global.CSSStyleSheet.prototype){return;}function CSSStyleSheet(){this._styleEl=document.createElement("style");this._styleEl.setAttribute("data-polyfilled","true");(document.head||document.getElementsByTagName("head")[0]).appendChild(this._styleEl);}CSSStyleSheet.prototype.replaceSync=function(cssText){if(this._styleEl.styleSheet){this._styleEl.styleSheet.cssText=cssText||"";}else{this._styleEl.textContent=cssText||"";}return this;};CSSStyleSheet.prototype.replace=function(cssText){var self=this;return new Promise(function(resolve){self.replaceSync(cssText);resolve(self);});};function defineAdoptedStyleSheets(doc){if(doc.adoptedStyleSheets!==undefined)return;var adopted=[];try{Object.defineProperty(doc,"adoptedStyleSheets",{get:function(){return adopted;},set:function(sheets){for(var i=0;i<adopted.length;i++){var old=adopted[i];if(old&&old._styleEl?.parentNode){old._styleEl.parentNode.removeChild(old._styleEl);}}adopted=sheets||[];for(var j=0;j<adopted.length;j++){if(adopted[j]?._styleEl){(document.head||document.getElementsByTagName("head")[0]).appendChild(adopted[j]._styleEl);}}}});}catch{doc.adoptedStyleSheets=adopted;}}defineAdoptedStyleSheets(document);global.CSSStyleSheet=CSSStyleSheet;})(global);function getHostFromCurrentUrl(){var href=window.location.href;var clean=href.split(/[?#]/)[0];var parts=clean.split("/");var lastPart=parts[parts.length-1];if(lastPart&&lastPart.indexOf(".")>-1){parts.pop();return parts.join("/");}else{var originMatch=clean.match(/^(https?:\/\/[^/]+)/i);return originMatch?originMatch[1]:clean;}}function getExt(id){var parts=id.split(".");return parts.length>1?"."+parts.pop():"";}function isSupportedExtension(ext){return(ext===".js"||ext===".mjs"||ext===".json"||ext===".css"||ext===".svg"||ext===".xml"||ext===".html");}function ensureJsExtension(outputFilePath){var clean=outputFilePath.split(/[?#]/)[0];var parts=clean.split("/");var last=parts[parts.length-1];if(last.indexOf(".")>-1){last=last.replace(/\.[^.]+$/,".js");}else{last=last+".js";}parts[parts.length-1]=last;return parts.join("/");}function registry(modules){for(var key in modules){if(modules.hasOwnProperty(key)&&!__modules__[key]){__modules__[key]=modules[key];}}}function RequireAsynchronously(id,path,url){var actualPath=url?url+path:getHostFromCurrentUrl()+"/"+path;var scriptLoader=document.createElement("script");scriptLoader.setAttribute("src",ensureJsExtension(actualPath));var head=document.head||document.getElementsByTagName("head")[0];if(typeof Promise!=="undefined"){var $this=new Promise(function(resolve,reject){scriptLoader.onload=function(){resolve(__modulePointer__[id].exports);};scriptLoader.onerror=function(err){reject(err);};});head.appendChild(scriptLoader);return $this;}else{this.then=function(resolve){scriptLoader.onload=function(){resolve(__modulePointer__[id].exports);};return this;};this["catch"]=function(reject){scriptLoader.onerror=reject;return this;};head.appendChild(scriptLoader);}}function requireByHttp(id,attributes){if(!id)return;var ext=getExt(id);if(!isSupportedExtension(ext)){return;}var moduleId=id;if(__asyncModulePointer__[moduleId]){return __asyncModulePointer__[moduleId];}var modulePath=moduleId.split("::")[1];var moduleUrl=/^https?:\/\//.test(attributes.address)?attributes.address.split(modulePath)[0]:null;var result=new RequireAsynchronously(moduleId,modulePath,moduleUrl);__asyncModulePointer__[moduleId]=result;return result;}function require(id){if(!id)return;var ext=getExt(id);if(!isSupportedExtension(ext)){return;}if(__modulePointer__[id]){return __modulePointer__[id].exports;}var moduleData=__modules__[id];if(!moduleData){throw new Error("Module not found: "+id);}var fn=moduleData[0];var mapping=moduleData[1];function localRequire(key){return require(mapping[key]);}function remoteRequire(key,attributes={}){attributes.address=key;return requireByHttp(mapping[key],attributes);}var module={exports:{}};__modulePointer__[id]=module;fn(localRequire,module.exports,module,remoteRequire);return module.exports;}registry(modules);require(entry);GlobalConstructor.prototype["*pointers"]=function(address){if(address==="&registry"){return registry;}else if(address==="&require"){return require;}return null;};})(typeof window!=="undefined"?Window:this,typeof window!=="undefined"?window:this,{"&::entry.js":[function(require,exports,module,requireByHttp){require("./assets/favicon.ico");require("./index.html");const Unnecessary=require("./internal/unnecessary.js").default;const greetings=require("./greetings.js").default;const CANONICAL_PROPERTY_ORDER=["--accent","font-family","color","font-weight","background","padding"];function sheetToCanonicalObject(sheet){const result={};for(const rule of sheet.cssRules){if(!rule.selectorText)continue;const style=rule.style;const collected={};for(const prop of style){if(prop.startsWith("--")){collected[prop]=style.getPropertyValue(prop).trim();}}if(style.fontFamily){collected["font-family"]=style.fontFamily;}if(style.color){collected["color"]=style.color;}if(style.fontWeight){collected["font-weight"]=style.fontWeight;}if(style.backgroundColor){collected["background"]=style.backgroundColor;}if(style.paddingTop&&style.paddingTop===style.paddingRight&&style.paddingTop===style.paddingBottom&&style.paddingTop===style.paddingLeft){collected["padding"]=style.paddingTop;}const out={};for(const key of CANONICAL_PROPERTY_ORDER){if(key in collected){out[key]=collected[key];}}if(Object.keys(out).length>0){result[rule.selectorText]=out;}}return result;}async function runAllTests(){runTest("Greeting Module Default Export",greetings,"Hello, World!");const rpc=await requireByHttp("./dynamic/rpc.js");runTest("RPC Module getMessage Output",rpc.getMessage(),"Hello, World! You alright, Mate?");const colors=await requireByHttp("./dynamic/colors.json",{with:{type:"json"}});runTest("Colors Module Dynamic JSON",colors.default,{"primary":"#2563eb","secondary":"#6b7280","accent":"#10b981"});const styles=await requireByHttp("./dynamic/styles.css",{namespace:"DynamicCSS",with:{type:"css"}});const expectedCSSObject={":root":{"--accent":"#2563eb"},"body":{"font-family":"sans-serif","background":"rgb(246, 247, 251)","padding":"20px"},"h1":{"color":"var(--accent)"},"p.styled":{"color":"rgb(16, 185, 129)","font-weight":"bold"}};try{styles.default instanceof CSSStyleSheet;runTest("Styles Module Dynamic CSS (native CSSStyleSheet)",sheetToCanonicalObject(styles.default),expectedCSSObject);}catch(err){runTest("Styles Module Dynamic CSS (unsupported runtime)",styles.default,`
        :root {
          --accent: #2563eb;
        }

        body {
          font-family: sans-serif;
          background: #f6f7fb;
          padding: 20px;
        }

        h1 {
          color: var(--accent);
        }

        p.styled {
          color: #10b981;
          font-weight: bold;
        }
      `);}const{twina}=await requireByHttp("./dynamic/twina.js");runTest("Twin A",twina(),"I'm used by A(1)!");const{twinb}=await requireByHttp("./dynamic/twinb.js");runTest("Twin B",twinb(),"I'm used by B(2)!");try{const somewhere=await requireByHttp("https://djsmicrofrontends.netlify.app/resources/somewhere.js",{namespace:"MicroFrontend"});runTest("Try => Somewhere Dynamic Module (Microfrontend)",somewhere.default,"Hello! I'm from somewhere!",true);}catch(err){runTest("Catch => Somewhere Dynamic Module (Microfrontend)","Error loading external dynamic module.","Error loading external dynamic module.",true);}}runAllTests();},{"./assets/favicon.ico":"&::assets/favicon.ico","./index.html":"&::index.html","./internal/unnecessary.js":"&::internal/unnecessary.js","./greetings.js":"&::greetings.js","./dynamic/rpc.js":"&::dynamic/rpc.js","./dynamic/colors.json":"&::dynamic/colors.json","./dynamic/styles.css":"&::dynamic/styles.css","./dynamic/twina.js":"&::dynamic/twina.js","./dynamic/twinb.js":"&::dynamic/twinb.js","https://djsmicrofrontends.netlify.app/resources/somewhere.js":"MicroFrontend::resources/somewhere.js"}],"&::index.html":[function(require,exports,module,requireByHttp){exports.default="<!DOCTYPE html><html lang=\"en\"><head><meta charset=\"UTF-8\"><title>Client Testing</title><link rel=\"icon\" href=\"./assets/favicon.ico\"/></head><body><h1>Client Testing</h1><script>/*** Normalize string for comparison:* - Convert CRLF to LF* - Preserve newlines at start/end*/function normalize(str) {return str.replace(/\\r\\n/g, \"\\n\").replace(/\\s+/g, \" \").trim();}// Setup mocks firstconst testResults = [];/*** runTest(name, input, expected, final)* * Executes a single test case by comparing the provided `input` with the `expected` output.* Both values are normalized using `normalize()` to avoid false negatives caused by * formatting differences (e.g., spacing, quotes, JSON formatting).* * Parameters:* - name (string): A descriptive name for the test case.* - input (any): The actual value or result produced by the module/code.* - expected (any): The expected value to compare against.* - final (boolean, optional): If set to true, the function will print a summary table*   of all test results recorded in `testResults` so far. Defaults to false.* * Behavior:* - Compares normalized input and expected values.* - Stores the result as { name, pass } in `testResults`.* - Prints PASS/FAIL for the current test.* - If the test fails, prints actual and expected values for debugging.* - If `final` is true, aggregates all test results and prints a summary table *   with total tests, passed, failed, and pass percentage per test name.*/function runTest(name, input, expected, final = false) {// Normalize both actual and expected resultsconst result = input;const pass = normalize(JSON.stringify(result)) === normalize(JSON.stringify(expected));// Store test resulttestResults.push({ name, pass });// Output resultconsole.log(`--- Test: ${name} ---`);console.log(pass ? 'PASS' : 'FAIL');if (!pass) {console.log('--- Output ---', result);console.log('--- Expected ---', expected);}if (final) {// Aggregate summary by test nameconst grouped = {};for (const { name, pass } of testResults) {if (!grouped[name]) grouped[name] = [];grouped[name].push(pass);}const summary = Object.entries(grouped).map(([name, results]) => {const total = results.length;const passed = results.filter(r => r).length;const failed = total - passed;const percent = total === 0 ? 0 : ((passed / total) * 100).toFixed(2);return { name, total, passed, failed, \"pass %\": percent };});console.table(summary, [\"name\", \"total\", \"passed\", \"failed\", \"pass %\"]);}}</script><script src=\"./entry.js\"></script></body></html>";},{}],"&::internal/unnecessary.js":[function(require,exports,module,requireByHttp){class Unnecessary{};exports.default=Unnecessary;},{}],"&::greetings.js":[function(require,exports,module,requireByHttp){exports.default="Hello, World!";},{}]},"&::entry.js");