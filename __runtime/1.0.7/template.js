/**
 * RUNTIME_CODE
 * 
 * This is the main runtime template generated by the JS bundler engine. 
 * It wraps all bundled modules, manages module registration and caching, 
 * handles synchronous and asynchronous module loading, and polyfills 
 * necessary browser features (e.g., CSSStyleSheet/adoptedStyleSheets). 
 * 
 * Key points:
 * - `GlobalConstructor` is typically `window` in the browser.
 * - `global` is the global object, usually also `window`.
 * - `modules` is an object containing all bundled modules keyed by module ID.
 * - `entry` is the entry module ID to start execution.
 * 
 * Responsibilities:
 * 1. Register all modules in a local registry (`__modules__`) and cache loaded modules (`__modulePointer__`).
 * 2. Provide `require()` for synchronous modules and dynamic/async `require()` for HTTP-loaded modules.
 * 3. Polyfill CSSStyleSheet and adoptedStyleSheets so styles can be injected dynamically.
 * 4. Automatically execute the entry module to start the application.
 * 5. Expose `*pointers` to access `registry` and `require` externally.
 * 
 * Usage:
 * - Bundler injects this runtime and populates `modules` and `entry`.
 * - Dynamic modules can be loaded asynchronously using URLs (HTTP/HTTPS) and optional namespaces.
 * - Synchronous modules are loaded from the pre-registered `modules` object.
 */
(function(GlobalConstructor, global, modules, entry) {
  // -------------------------------------------------------------------------
  // Internal registries and caches
  // -------------------------------------------------------------------------
  var __modules__ = {};              // All registered modules
  var __modulePointer__ = {};        // Cache for loaded modules
  var __asyncModulePointer__ = {};   // Cache for dynamically loaded modules

  // Polyfill for CSSStyleSheet and adoptedStyleSheets
  (function(global) {
    // If browser already supports CSSStyleSheet with replaceSync, skip polyfill
    if (typeof global.CSSStyleSheet === "function" && "replaceSync" in global.CSSStyleSheet.prototype) {
      return;
    }

    // Polyfilled CSSStyleSheet constructor
    function CSSStyleSheet() {
      this._styleEl = document.createElement("style");
      this._styleEl.setAttribute("data-polyfilled", "true");
      var head = document.head || document.getElementsByTagName("head")[0];
      head.appendChild(this._styleEl);
    }

    // Synchronous stylesheet replacement
    CSSStyleSheet.prototype.replaceSync = function(cssText) {
      if (this._styleEl.styleSheet) {
        // For IE8 and older IE versions
        this._styleEl.styleSheet.cssText = cssText || "";
      } else {
        // For modern browsers
        this._styleEl.textContent = cssText || "";
      }
      return this;
    };

    // Asynchronous stylesheet replacement returning a Promise
    CSSStyleSheet.prototype.replace = function(cssText) {
      var self = this;
      return new Promise(function(resolve) {
        self.replaceSync(cssText);
        resolve(self);
      });
    };

    // Define adoptedStyleSheets property on the document object
    function defineAdoptedStyleSheets(doc) {
      if (doc.adoptedStyleSheets !== undefined) return;

      var adopted = [];

      // Try to define property using Object.defineProperty
      try {
        Object.defineProperty(doc, "adoptedStyleSheets", {
          get: function() {
            return adopted;
          },
          set: function(sheets) {
            // Remove old stylesheets
            for (var i = 0; i < adopted.length; i++) {
              var old = adopted[i];
              if (old && old._styleEl && old._styleEl.parentNode) {
                old._styleEl.parentNode.removeChild(old._styleEl);
              }
            }
            // Assign new sheets
            adopted = sheets || [];
            // Append new stylesheets to head
            for (var j = 0; j < adopted.length; j++) {
              if (adopted[j] && adopted[j]._styleEl) {
                var head = document.head || document.getElementsByTagName("head")[0];
                head.appendChild(adopted[j]._styleEl);
              }
            }
          }
        });
      } catch (e) {
        // Fallback for IE8 which does not allow defineProperty on DOM objects
        doc.adoptedStyleSheets = adopted;
      }
    }

    defineAdoptedStyleSheets(document);
    global.CSSStyleSheet = CSSStyleSheet;
  })(global);

  // Extract host or base path from current window URL
  function getHostFromCurrentUrl() {
    var href = window.location.href;
    var clean = href.split(/[?#]/)[0];
    var parts = clean.split("/");
    var lastPart = parts[parts.length - 1];

    if (lastPart && lastPart.indexOf(".") > -1) {
      // If last part is a file, remove it
      parts.pop();
      return parts.join("/");
    } else {
      // Extract origin (protocol + host + port)
      var originMatch = clean.match(/^(https?:\/\/[^/]+)/i);
      return originMatch ? originMatch[1] : clean;
    }
  }

  // Get file extension from an id string
  function getExt(id) {
    var parts = id.split(".");
    return parts.length > 1 ? "." + parts.pop() : "";
  }

  // Ensure file path ends with .js
  function ensureJsExtension(outputFilePath) {
    var clean = outputFilePath.split(/[?#]/)[0];
    var parts = clean.split("/");
    var last = parts[parts.length - 1];

    if (last.indexOf(".") > -1) {
      last = last.replace(/\.[^.]+$/, ".js");
    } else {
      last = last + ".js";
    }
    parts[parts.length - 1] = last;
    return parts.join("/");
  }

  // The `registry` function registers modules into the global `__modules__` object
  // It checks if the module is already registered, and if not, it adds the module to `__modules__`
  function registry(modules) {
    // Iterate through each module in the 'modules' object using a traditional 'for...in' loop
    for (var key in modules) {
      // Ensure that the property is a direct property of 'modules', not inherited from its prototype
      if (modules.hasOwnProperty(key)) {
        // Check if the module with the given key is not already registered in __modules__
        if (!__modules__[key]) {
          // If not already registered, add it to __modules__ with the corresponding module value
          __modules__[key] = modules[key];
        }
      }
    }
  }

  // ---------------------------------------------------------------------------
  // RequireAsynchronously()
  // ---------------------------------------------------------------------------
  // Description:
  // Dynamically loads a JavaScript module via <script> injection and returns
  // a Promise-like object that resolves when the script is successfully loaded.
  //
  // Purpose:
  // This function enables the runtime to fetch and execute remote modules
  // from HTTP/HTTPS endpoints on demand (lazy loading). It integrates seamlessly
  // with the main `require()` function when the module identifier includes
  // special markers like `<HTTP>` or `<HTTPS>`.
  //
  // Behavior:
  // - Automatically appends the `.js` extension if missing.
  // - Injects the script into the document head.
  // - Resolves to the module’s exported object once loaded.
  // - Supports a Promise-based interface with a fallback for older browsers.
  //
  // Parameters:
  // @param {string} id   - Unique module identifier used for caching and export lookup.
  // @param {string} path - Path (relative or absolute) to the module file (without host).
  //
  // Returns:
  // - Promise resolving to the module's exports (modern browsers)
  // - Promise-like object with `.then()` and `.catch()` (legacy fallback)
  // ---------------------------------------------------------------------------
  function RequireAsynchronously(id, path, url) {
    // Construct the full URL using the current host as the base.
    // Example:
    //   __INJECT_HOST__ → "http://localhost:8000"
    //   path → "components/counter.js"
    //   result → "http://localhost:8000/components/counter.js"
    var actualPath = url ? url + path : __INJECT_HOST__ + "/" + path;

    // Create a <script> element to load the remote module.
    var scriptLoader = document.createElement("script");

    // Ensure the URL has a valid .js extension before loading.
    scriptLoader.setAttribute("src", ensureJsExtension(actualPath));

    // Retrieve the <head> element for safe script injection.
    var head = document.head || document.getElementsByTagName("head")[0];

    // --- Modern Browsers: Promise-based Async Loading ---
    if (typeof Promise !== "undefined") {
      // Wrap the script loading lifecycle inside a Promise.
      var $this = new Promise(function (resolve, reject) {
        // Resolve when the script has been successfully loaded and registered.
        scriptLoader.onload = function () {
          resolve(__modulePointer__[id].exports);
        };
        // Reject the promise if the script fails to load.
        scriptLoader.onerror = function (err) {
          reject(err);
        };
      });

      // Begin script injection.
      head.appendChild(scriptLoader);

      // Return the promise for chaining.
      return $this;
    }

    // --- Legacy Fallback: No native Promise support ---
    else {
      // Minimal .then() polyfill for async behavior.
      this.then = function (resolve) {
        scriptLoader.onload = function () {
          resolve(__modulePointer__[id].exports);
        };
        return this;
      };

      // Minimal .catch() polyfill for error handling.
      this["catch"] = function (reject) {
        scriptLoader.onerror = reject;
        return this;
      };

      // Start loading the script.
      head.appendChild(scriptLoader);
    }
  }

  // ---------------------------------------------------------------------------
  // require()
  // ---------------------------------------------------------------------------
  // Description:
  // Core runtime loader function that supports both synchronous and asynchronous
  // module resolution. It mimics CommonJS-style `require()` but adds extended
  // capabilities for fetching remote modules over HTTP/HTTPS.
  //
  // Purpose:
  // This function serves as the unified module entry point in the runtime.
  // It decides whether to load a module immediately (from the local registry)
  // or defer its loading asynchronously via <script> injection.
  //
  // Behavior:
  // - If the module ID contains `<HTTP>` or `<HTTPS>`, it triggers async loading.
  // - Otherwise, it resolves the module synchronously from the in-memory registry.
  // - Handles dependency mapping, caching, and export resolution.
  //
  // Parameters:
  // @param {string} id - The unique identifier or path of the requested module.
  //
  // Returns:
  // - The module’s exported object (for synchronous modules).
  // - A Promise-like object (for asynchronous modules).
  // ---------------------------------------------------------------------------
  function require(id, name = "") {
    if (!id) return;

    // -------------------------------------------------------------------------
    // Step 1: Determine whether the module should be loaded asynchronously
    // -------------------------------------------------------------------------
    // The presence of `<HTTP>` or `<HTTPS>` markers indicates that the module
    // resides remotely and must be fetched dynamically at runtime.
    var asynchronously = id.indexOf("<HTTP>") !== -1 || id.indexOf("<HTTPS>") !== -1;

    if (asynchronously) {
      // -----------------------------------------------------------------------
      // Asynchronous Module Loading Path
      // -----------------------------------------------------------------------

      // Identify the separator based on the protocol marker.
      // Example:
      //   "pkg/<HTTP>::lib/component.js" → separator "/<HTTP>"
      var separator = null;
      if (id.indexOf("<HTTP>") !== -1) {
        separator = "/<HTTP>";
      } else if (id.indexOf("<HTTPS>") !== -1) {
        separator = "/<HTTPS>";
      }

      // Extract the base module identifier before the marker.
      var moduleId = id.split(separator)[0];

      // If the async module is already loaded, return its cached reference.
      if (__asyncModulePointer__[moduleId]) {
        return __asyncModulePointer__[moduleId];
      }

      // Extract file path after namespace, if any.
      var modulePath = moduleId.split("::")[1];

      // Derive module host URL if the name indicates a full HTTP(S) path.
      var moduleUrl = /^https?:\/\//.test(name)
        ? name.split(modulePath)[0]
        : null;

      // Initialize asynchronous module loader.
      var requireAsynchronously = new RequireAsynchronously(
        moduleId,
        modulePath,
        moduleUrl
      );

      // Store the async module reference in the global async registry.
      __asyncModulePointer__[moduleId] = requireAsynchronously;

      // Return the Promise-like loader for chaining (.then/.catch).
      return requireAsynchronously;
    }

    // -------------------------------------------------------------------------
    // Synchronous Module Loading Path
    // -------------------------------------------------------------------------

    // Only process known module file types.
    // Any unsupported extension (e.g., images, fonts) is ignored.
    var ext = getExt(id);
    if (!(ext === ".js" || ext === ".mjs" || ext === ".json" || ext === ".css" || ext === ".svg" || ext === ".xml" || ext === ".html")) {
      return;
    }

    // Return cached exports if this module has been loaded previously.
    if (__modulePointer__[id]) {
      return __modulePointer__[id].exports;
    }

    // Retrieve the module definition from the central registry.
    // Each module entry in __modules__ is stored as:
    //   [ factoryFunction, dependencyMapping ]
    var moduleData = __modules__[id];
    if (!moduleData) {
      throw new Error("Module not found: " + id);
    }

    // Destructure the stored data: the factory function and dependency map.
    var fn = moduleData[0];
    var mapping = moduleData[1];

    // Create a scoped version of 'require' for dependency resolution.
    // This ensures that internal module dependencies are correctly mapped.
    function localRequire(name) {
      return require(mapping[name], name);
    }

    // Initialize a new module container and cache it for reuse.
    var module = { exports: {} };
    __modulePointer__[id] = module;

    // Execute the factory function in CommonJS style:
    // fn(require, exports, module)
    fn(localRequire, module.exports, module);

    // Return the module’s exported content.
    return module.exports;
  }

  // Start registering modules
  registry(modules);

  // Start execution from entry module
  require(entry);

  GlobalConstructor.prototype["*pointers"] = function(address) {
    if (address === "&registry") {
      return registry;
    } else if (address === "&require") {
      return require;
    }
    return null;
  }; 
})(
  typeof window !== "undefined" ? Window : this,
  typeof window !== "undefined" ? window : this,
  __INJECT_MODULES__,
  __INJECT_ENTRY__
);
