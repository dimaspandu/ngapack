/**
 * RUNTIME_CODE
 * 
 * This is the main runtime template generated by the JS bundler engine. 
 * It wraps all bundled modules, manages module registration and caching, 
 * handles synchronous and asynchronous module loading, and polyfills 
 * necessary browser features (e.g., CSSStyleSheet/adoptedStyleSheets). 
 * 
 * Key points:
 * - `GlobalConstructor` is typically `window` in the browser.
 * - `global` is the global object, usually also `window`.
 * - `modules` is an object containing all bundled modules keyed by module ID.
 * - `entry` is the entry module ID to start execution.
 * 
 * Responsibilities:
 * 1. Register all modules in a local registry (`__modules__`) and cache loaded modules (`__modulePointer__`).
 * 2. Provide `require()` for synchronous modules and dynamic/async `require()` for HTTP-loaded modules.
 * 3. Polyfill CSSStyleSheet and adoptedStyleSheets so styles can be injected dynamically.
 * 4. Automatically execute the entry module to start the application.
 * 5. Expose `*pointers` to access `registry` and `require` externally.
 * 
 * Usage:
 * - Bundler injects this runtime and populates `modules` and `entry`.
 * - Dynamic modules can be loaded asynchronously using URLs (HTTP/HTTPS) and optional namespaces.
 * - Synchronous modules are loaded from the pre-registered `modules` object.
 */
(function(GlobalConstructor, global, modules, entry) {
  var __modules__ = {};
  var __modulePointer__ = {};
  var __asyncModulePointer__ = {};

  // Polyfill for CSSStyleSheet and adoptedStyleSheets
  (function(global) {
    // If browser already supports CSSStyleSheet with replaceSync, skip polyfill
    if (typeof global.CSSStyleSheet === "function" && "replaceSync" in global.CSSStyleSheet.prototype) {
      return;
    }

    // Polyfilled CSSStyleSheet constructor
    function CSSStyleSheet() {
      this._styleEl = document.createElement("style");
      this._styleEl.setAttribute("data-polyfilled", "true");
      var head = document.head || document.getElementsByTagName("head")[0];
      head.appendChild(this._styleEl);
    }

    // Synchronous stylesheet replacement
    CSSStyleSheet.prototype.replaceSync = function(cssText) {
      if (this._styleEl.styleSheet) {
        // For IE8 and older IE versions
        this._styleEl.styleSheet.cssText = cssText || "";
      } else {
        // For modern browsers
        this._styleEl.textContent = cssText || "";
      }
      return this;
    };

    // Asynchronous stylesheet replacement returning a Promise
    CSSStyleSheet.prototype.replace = function(cssText) {
      var self = this;
      return new Promise(function(resolve) {
        self.replaceSync(cssText);
        resolve(self);
      });
    };

    // Define adoptedStyleSheets property on the document object
    function defineAdoptedStyleSheets(doc) {
      if (doc.adoptedStyleSheets !== undefined) return;

      var adopted = [];

      // Try to define property using Object.defineProperty
      try {
        Object.defineProperty(doc, "adoptedStyleSheets", {
          get: function() {
            return adopted;
          },
          set: function(sheets) {
            // Remove old stylesheets
            for (var i = 0; i < adopted.length; i++) {
              var old = adopted[i];
              if (old && old._styleEl && old._styleEl.parentNode) {
                old._styleEl.parentNode.removeChild(old._styleEl);
              }
            }
            // Assign new sheets
            adopted = sheets || [];
            // Append new stylesheets to head
            for (var j = 0; j < adopted.length; j++) {
              if (adopted[j] && adopted[j]._styleEl) {
                var head = document.head || document.getElementsByTagName("head")[0];
                head.appendChild(adopted[j]._styleEl);
              }
            }
          }
        });
      } catch (e) {
        // Fallback for IE8 which does not allow defineProperty on DOM objects
        doc.adoptedStyleSheets = adopted;
      }
    }

    defineAdoptedStyleSheets(document);
    global.CSSStyleSheet = CSSStyleSheet;
  })(global);

  // Extract host or base path from current window URL
  function getHostFromCurrentUrl() {
    var href = window.location.href;
    var clean = href.split(/[?#]/)[0];
    var parts = clean.split("/");
    var lastPart = parts[parts.length - 1];

    if (lastPart && lastPart.indexOf(".") > -1) {
      // If last part is a file, remove it
      parts.pop();
      return parts.join("/");
    } else {
      // Extract origin (protocol + host + port)
      var originMatch = clean.match(/^(https?:\/\/[^/]+)/i);
      return originMatch ? originMatch[1] : clean;
    }
  }

  // Get file extension from an id string
  function getExt(id) {
    var parts = id.split(".");
    return parts.length > 1 ? "." + parts.pop() : "";
  }

  // Ensure file path ends with .js
  function ensureJsExtension(outputFilePath) {
    var clean = outputFilePath.split(/[?#]/)[0];
    var parts = clean.split("/");
    var last = parts[parts.length - 1];

    if (last.indexOf(".") > -1) {
      last = last.replace(/\.[^.]+$/, ".js");
    } else {
      last = last + ".js";
    }
    parts[parts.length - 1] = last;
    return parts.join("/");
  }

  // The `registry` function registers modules into the global `__modules__` object
  // It checks if the module is already registered, and if not, it adds the module to `__modules__`
  function registry(modules) {
    // Iterate through each module in the 'modules' object using a traditional 'for...in' loop
    for (var key in modules) {
      // Ensure that the property is a direct property of 'modules', not inherited from its prototype
      if (modules.hasOwnProperty(key)) {
        // Check if the module with the given key is not already registered in __modules__
        if (!__modules__[key]) {
          // If not already registered, add it to __modules__ with the corresponding module value
          __modules__[key] = modules[key];
        }
      }
    }
  }

  // Load script asynchronously and return a Promise-like object
  function RequireAsynchronously(idAsAPath, namespace) {
    var actualPath = idAsAPath.replace("&", getHostFromCurrentUrl());

    var scriptLoader = document.createElement("script");

    scriptLoader.setAttribute("src", ensureJsExtension(actualPath));
    
    var head = document.head || document.getElementsByTagName("head")[0];

    var moduleId = namespace ? namespace : idAsAPath;

    // Promise-based async loading
    if (typeof Promise !== "undefined") {
      const $this = new Promise(function(resolve, reject) {
        scriptLoader.onload = function() {
          resolve(__modulePointer__[moduleId].exports);
        };
        scriptLoader.onerror = function(err) {
          reject(err);
        };
      });

      head.appendChild(scriptLoader);

      return $this;
    }
    // Fallback for browsers without Promise
    else {
      this.then = function(resolve) {
        scriptLoader.onload = function() {
          resolve(__modulePointer__[moduleId].exports);
        };
        return this;
      };

      this["catch"] = function(reject) {
        scriptLoader.onerror = reject;
        return this;
      };
      
      head.appendChild(scriptLoader);
    }
  }

  // Main require function to load modules synchronously or asynchronously
  function require(id) {
    if (!id) return;

    var asynchronously = id.indexOf("<HTTP>") !== -1 || id.indexOf("<HTTPS>") !== -1;

    if (asynchronously) {
      // Asynchronous module loading
      var separator = null;
      if (id.indexOf("<HTTP>") !== -1) {
        separator = "/<HTTP>";
      } else if (id.indexOf("<HTTPS>") !== -1) {
        separator = "/<HTTPS>";
      }

      var isExternalUrl = /^https?:\/\//.test(id);
      var actualId = id.split(separator)[0];
      var namespace = id.split(separator)[1].substring(1);
      var moduleId = actualId + namespace;

      // Reuse existing async module if already loaded
      if (__asyncModulePointer__[moduleId]) {
        return __asyncModulePointer__[moduleId];
      }

      var requireAsynchronously = null;
      var hasANamespace = namespace.length > 0;

      if (isExternalUrl && hasANamespace) {
        requireAsynchronously = new RequireAsynchronously(actualId, namespace);
      } else {
        requireAsynchronously = new RequireAsynchronously(actualId);
      }

      __asyncModulePointer__[moduleId] = requireAsynchronously;
      return requireAsynchronously;
    }

    // Handle synchronous modules
    var ext = getExt(id);
    if (!(ext === ".js" || ext === ".mjs" || ext === ".json" || ext === ".css" || ext === ".svg" || ext === ".xml" || ext === ".html")) {
      return;
    }

    // Return already cached module if available
    if (__modulePointer__[id]) {
      return __modulePointer__[id].exports;
    }

    // Retrieve module definition
    var moduleData = __modules__[id];
    if (!moduleData) {
      throw new Error("Module not found: " + id);
    }

    var fn = moduleData[0];
    var mapping = moduleData[1];

    // Local require function for module mapping
    function localRequire(name) {
      return require(mapping[name]);
    }

    // Initialize module object
    var module = { exports: {} };
    __modulePointer__[id] = module;

    // Execute module function
    fn(localRequire, module.exports, module);
    return module.exports;
  }

  // Start registering modules
  registry(modules);

  // Start execution from entry module
  require(entry);

  GlobalConstructor.prototype["*pointers"] = function(address) {
    if (address === "&registry") {
      return registry;
    } else if (address === "&require") {
      return require;
    }
    return null;
  }; 
})(
  typeof window !== "undefined" ? Window : this,
  typeof window !== "undefined" ? window : this,
  {
    // Entry module
    "&/entry.js": [
      function(require, exports, module) {
        var greetings = require("./greetings.js").default;

        async function runAllTests() {
          // Test synchronous module first
          runTest("Greeting Module Default Export", greetings, "Hello, World!");

          try {
            // Test RPC module with dynamic loading
            const rpc = await require("./dynamic/rpc.js/<HTTP>/");
            runTest("RPC Module getMessage Output", rpc.getMessage(), "Hello, World!");

            // Test dynamic JSON module using namespace
            const colors = await require("./dynamic/colors.json/<HTTP>/colors.namespace");
            runTest("Colors Module Dynamic JSON", colors.default, {
              "primary": "#2563eb",
              "secondary": "#6b7280",
              "accent": "#10b981"
            });

            // Test dynamic CSS module using namespace
            const styles = await require("./dynamic/styles.css/<HTTP>/styles.namespace");
            runTest(
              "Styles Module Dynamic CSS",
              styles.default,
              (`
                :root {
                  --accent: #2563eb;
                }

                body {
                  font-family: sans-serif;
                  background: #f6f7fb;
                  padding: 20px;
                }

                h1 {
                  color: var(--accent);
                }

                p.styled {
                  color: #10b981;
                  font-weight: bold;
                }
              `)
            );

            const somewhere = await require("https://www.microfrontends.com/resources/somewhere.css/<HTTP>/");
            runTest(
              "Somewhere Dynamic Module (Microfrontend)",
              somewhere.default,
              (`
                * {
                  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
                  font-size: 16px;
                  margin: 0;
                  padding: 0;
                }
              `),
              true
            );
            
          } catch (err) {
            console.error("Error loading dynamic module:", err);
          }
        }

        // Start all tests
        runAllTests();
      },
      {
        "./greetings.js": "&/greetings.js",
        "./dynamic/rpc.js/<HTTP>/": "&/dynamic/rpc.js/<HTTP>/",
        "./dynamic/colors.json/<HTTP>/colors.namespace": "&/dynamic/colors.json/<HTTP>/colors.namespace",
        "./dynamic/styles.css/<HTTP>/styles.namespace":"&/dynamic/styles.css/<HTTP>",
        "https://www.microfrontends.com/resources/somewhere.css/<HTTP>/": "&/resources/somewhere.css/<HTTP>/"
      }
    ],
    // Greetings module
    "&/greetings.js": [
      function(require, exports, module) {
        exports["default"] = "Hello, World!";
      },
      {}
    ]
  },
  "&/entry.js"
);

