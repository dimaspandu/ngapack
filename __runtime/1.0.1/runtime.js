/**
 * Normalize string for comparison:
 * - Convert CRLF to LF
 * - Preserve newlines at start/end
 */
function normalize(str) {
  return str.replace(/\r\n/g, "\n").replace(/\s+/g, " ").trim();
}

// Setup mocks first
const testResults = [];

/**
 * runTest(name, input, expected, final)
 * 
 * Executes a single test case by comparing the provided `input` with the `expected` output.
 * Both values are normalized using `normalize()` to avoid false negatives caused by 
 * formatting differences (e.g., spacing, quotes, JSON formatting).
 * 
 * Parameters:
 * - name (string): A descriptive name for the test case.
 * - input (any): The actual value or result produced by the module/code.
 * - expected (any): The expected value to compare against.
 * - final (boolean, optional): If set to true, the function will print a summary table
 *   of all test results recorded in `testResults` so far. Defaults to false.
 * 
 * Behavior:
 * - Compares normalized input and expected values.
 * - Stores the result as { name, pass } in `testResults`.
 * - Prints PASS/FAIL for the current test.
 * - If the test fails, prints actual and expected values for debugging.
 * - If `final` is true, aggregates all test results and prints a summary table 
 *   with total tests, passed, failed, and pass percentage per test name.
 */
function runTest(name, input, expected, final = false) {
  // Normalize both actual and expected results
  const result = input;
  const pass = normalize(JSON.stringify(result)) === normalize(JSON.stringify(expected));

  // Store test result
  testResults.push({ name, pass });

  // Output result
  console.log(`--- Test: ${name} ---`);
  console.log(pass ? 'PASS' : 'FAIL');

  if (!pass) {
    console.log('--- Output ---', result);
    console.log('--- Expected ---', expected);
  }

  if (final) {
    // Aggregate summary by test name
    const grouped = {};
    for (const { name, pass } of testResults) {
      if (!grouped[name]) grouped[name] = [];
      grouped[name].push(pass);
    }

    const summary = Object.entries(grouped).map(([name, results]) => {
      const total = results.length;
      const passed = results.filter(r => r).length;
      const failed = total - passed;
      const percent = total === 0 ? 0 : ((passed / total) * 100).toFixed(2);
      return { name, total, passed, failed, "pass %": percent };
    });

    console.table(summary, ["name", "total", "passed", "failed", "pass %"]);
  }
}

/**
 * RUNTIME_CODE
 * 
 * This is the main runtime template generated by the JS bundler engine. 
 * It wraps all bundled modules, manages module registration and caching, 
 * handles synchronous and asynchronous module loading, and polyfills 
 * necessary browser features (e.g., CSSStyleSheet/adoptedStyleSheets). 
 * 
 * Key points:
 * - `GlobalConstructor` is typically `window` in the browser.
 * - `global` is the global object, usually also `window`.
 * - `modules` is an object containing all bundled modules keyed by module ID.
 * - `entry` is the entry module ID to start execution.
 * 
 * Responsibilities:
 * 1. Register all modules in a local registry (`__modules__`) and cache loaded modules (`__modulePointer__`).
 * 2. Provide `require()` for synchronous modules and dynamic/async `require()` for HTTP-loaded modules.
 * 3. Polyfill CSSStyleSheet and adoptedStyleSheets so styles can be injected dynamically.
 * 4. Automatically execute the entry module to start the application.
 * 5. Expose `*pointers` to access `registry` and `require` externally.
 * 
 * This runtime code can be copied and pasted directly into the browser console 
 * and will run immediately, provided that any dynamically imported files are 
 * available at their specified URLs or paths.
 * 
 * Usage:
 * - Bundler injects this runtime and populates `modules` and `entry`.
 * - Dynamic modules can be loaded asynchronously using URLs (HTTP/HTTPS) and optional namespaces.
 * - Synchronous modules are loaded from the pre-registered `modules` object.
 */
(function(GlobalConstructor, global, modules, entry) {
  var __modules__ = {};
  var __modulePointer__ = {};
  var __asyncModulePointer__ = {};

  // Polyfill for CSSStyleSheet and adoptedStyleSheets
  (function(global) {
    // If browser already supports CSSStyleSheet with replaceSync, skip polyfill
    if (typeof global.CSSStyleSheet === "function" && "replaceSync" in global.CSSStyleSheet.prototype) {
      return;
    }

    // Polyfilled CSSStyleSheet constructor
    function CSSStyleSheet() {
      this._styleEl = document.createElement("style");
      this._styleEl.setAttribute("data-polyfilled", "true");
      var head = document.head || document.getElementsByTagName("head")[0];
      head.appendChild(this._styleEl);
    }

    // Synchronous stylesheet replacement
    CSSStyleSheet.prototype.replaceSync = function(cssText) {
      if (this._styleEl.styleSheet) {
        // For IE8 and older IE versions
        this._styleEl.styleSheet.cssText = cssText || "";
      } else {
        // For modern browsers
        this._styleEl.textContent = cssText || "";
      }
      return this;
    };

    // Asynchronous stylesheet replacement returning a Promise
    CSSStyleSheet.prototype.replace = function(cssText) {
      var self = this;
      return new Promise(function(resolve) {
        self.replaceSync(cssText);
        resolve(self);
      });
    };

    // Define adoptedStyleSheets property on the document object
    function defineAdoptedStyleSheets(doc) {
      if (doc.adoptedStyleSheets !== undefined) return;

      var adopted = [];

      // Try to define property using Object.defineProperty
      try {
        Object.defineProperty(doc, "adoptedStyleSheets", {
          get: function() {
            return adopted;
          },
          set: function(sheets) {
            // Remove old stylesheets
            for (var i = 0; i < adopted.length; i++) {
              var old = adopted[i];
              if (old && old._styleEl && old._styleEl.parentNode) {
                old._styleEl.parentNode.removeChild(old._styleEl);
              }
            }
            // Assign new sheets
            adopted = sheets || [];
            // Append new stylesheets to head
            for (var j = 0; j < adopted.length; j++) {
              if (adopted[j] && adopted[j]._styleEl) {
                var head = document.head || document.getElementsByTagName("head")[0];
                head.appendChild(adopted[j]._styleEl);
              }
            }
          }
        });
      } catch (e) {
        // Fallback for IE8 which does not allow defineProperty on DOM objects
        doc.adoptedStyleSheets = adopted;
      }
    }

    defineAdoptedStyleSheets(document);
    global.CSSStyleSheet = CSSStyleSheet;
  })(global);

  // Extract host or base path from current window URL
  function getHostFromCurrentUrl() {
    var href = window.location.href;
    var clean = href.split(/[?#]/)[0];
    var parts = clean.split("/");
    var lastPart = parts[parts.length - 1];

    if (lastPart && lastPart.indexOf(".") > -1) {
      // If last part is a file, remove it
      parts.pop();
      return parts.join("/");
    } else {
      // Extract origin (protocol + host + port)
      var originMatch = clean.match(/^(https?:\/\/[^/]+)/i);
      return originMatch ? originMatch[1] : clean;
    }
  }

  // Get file extension from an id string
  function getExt(id) {
    var parts = id.split(".");
    return parts.length > 1 ? "." + parts.pop() : "";
  }

  // Ensure file path ends with .js
  function ensureJsExtension(outputFilePath) {
    var clean = outputFilePath.split(/[?#]/)[0];
    var parts = clean.split("/");
    var last = parts[parts.length - 1];

    if (last.indexOf(".") > -1) {
      last = last.replace(/\.[^.]+$/, ".js");
    } else {
      last = last + ".js";
    }
    parts[parts.length - 1] = last;
    return parts.join("/");
  }

  // The `registry` function registers modules into the global `__modules__` object
  // It checks if the module is already registered, and if not, it adds the module to `__modules__`
  function registry(modules) {
    // Iterate through each module in the 'modules' object using a traditional 'for...in' loop
    for (var key in modules) {
      // Ensure that the property is a direct property of 'modules', not inherited from its prototype
      if (modules.hasOwnProperty(key)) {
        // Check if the module with the given key is not already registered in __modules__
        if (!__modules__[key]) {
          // If not already registered, add it to __modules__ with the corresponding module value
          __modules__[key] = modules[key];
        }
      }
    }
  }

  // Load script asynchronously and return a Promise-like object
  function RequireAsynchronously(idAsAPath, namespace) {
    var actualPath = idAsAPath.replace("&", getHostFromCurrentUrl());

    var scriptLoader = document.createElement("script");
    scriptLoader.setAttribute("src", ensureJsExtension(actualPath));
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(scriptLoader);

    var moduleId = namespace ? namespace : idAsAPath;

    if (typeof Promise !== "undefined") {
      // Promise-based async loading
      return new Promise(function(resolve, reject) {
        scriptLoader.onload = function() {
          resolve(__modulePointer__[moduleId].exports);
        };
        scriptLoader.onerror = function(err) {
          reject(err);
        };
      });
    } else {
      // Fallback for browsers without Promise
      this.then = function(resolve) {
        scriptLoader.onload = function() {
          resolve(__modulePointer__[moduleId].exports);
        };
        return this;
      };
      this["catch"] = function(reject) {
        scriptLoader.onerror = reject;
        return this;
      };
    }
  }

  // Main require function to load modules synchronously or asynchronously
  function require(id) {
    if (!id) return;

    var asynchronously = id.indexOf("<HTTP>") !== -1 || id.indexOf("<HTTPS>") !== -1;

    if (asynchronously) {
      // Asynchronous module loading
      var separator = null;
      if (id.indexOf("<HTTP>") !== -1) {
        separator = "/<HTTP>";
      } else if (id.indexOf("<HTTPS>") !== -1) {
        separator = "/<HTTPS>";
      }

      var isExternalUrl = /^https?:\/\//.test(id);
      var actualId = id.split(separator)[0];
      var namespace = id.split(separator)[1].substring(1);
      var moduleId = actualId + namespace;

      // Reuse existing async module if already loaded
      if (__asyncModulePointer__[moduleId]) {
        return __asyncModulePointer__[moduleId];
      }

      var requireAsynchronously = null;
      var hasANamespace = namespace.length > 0;

      if (isExternalUrl && hasANamespace) {
        requireAsynchronously = new RequireAsynchronously(actualId, namespace);
      } else {
        requireAsynchronously = new RequireAsynchronously(actualId);
      }

      __asyncModulePointer__[moduleId] = requireAsynchronously;
      return requireAsynchronously;
    }

    // Handle synchronous modules
    var ext = getExt(id);
    if (!(ext === ".js" || ext === ".mjs" || ext === ".json" || ext === ".css" || ext === ".svg" || ext === ".xml" || ext === ".html")) {
      return;
    }

    // Return already cached module if available
    if (__modulePointer__[id]) {
      return __modulePointer__[id].exports;
    }

    // Retrieve module definition
    var moduleData = __modules__[id];
    if (!moduleData) {
      throw new Error("Module not found: " + id);
    }

    var fn = moduleData[0];
    var mapping = moduleData[1];

    // Local require function for module mapping
    function localRequire(name) {
      return require(mapping[name]);
    }

    // Initialize module object
    var module = { exports: {} };
    __modulePointer__[id] = module;

    // Execute module function
    fn(localRequire, module.exports, module);
    return module.exports;
  }

  // Start registering modules
  registry(modules);

  // Start execution from entry module
  require(entry);

  GlobalConstructor.prototype["*pointers"] = function(address) {
    if (address === "&registry") {
      return registry;
    } else if (address === "&require") {
      return require;
    }
    return null;
  }; 
})(
  typeof window !== "undefined" ? Window : this,
  typeof window !== "undefined" ? window : this,
  {
    // Entry module
    "&/entry.js": [
      function(require, exports, module) {
        // Example usage in entry module
        var greetings = require("./greetings.js").default;

        // Test synchronous module
        runTest("Greeting Module Default Export", greetings, "Hello, World!");
      },
      { "./greetings.js": "&/greetings.js" }
    ],
    // Greetings module
    "&/greetings.js": [
      function(require, exports, module) {
        exports["default"] = "Hello, World!";

        // Test export functionality
        runTest("Greetings Module Exported Value", exports.default, "Hello, World!");
      },
      {}
    ]
  },
  "&/entry.js"
);

(function(global, modules, entry) {
  global["*pointers"]("&registry")(modules);
  global["*pointers"]("&require")(entry);
})(
  typeof window !== "undefined" ? window : this,
  {
    "&/dynamic/colors.json": [
      function(require, exports, module) {
        exports.default = {
          "primary": "#2563eb",
          "secondary": "#6b7280",
          "accent": "#10b981"
        };

        // Test Case for colors.json export:
        runTest(
          "Colors Module Default Export Object",
          exports.default,
          {
            "primary": "#2563eb",
            "secondary": "#6b7280",
            "accent": "#10b981"
          },
          true
        );
      },
      {}
    ]
  },
  "&/dynamic/colors.json"
);
