/**
 * Bundler runtime (contributor notes).
 *
 * This file is the execution core generated by the bundler.
 * Most logic here is tightly coupled to the output format.
 *
 * Before modifying:
 * - Assume external bundles depend on current behavior
 * - Small changes can break async loading or CSS handling
 * - Prefer additive changes over refactors
 *
 * Invariants:
 * - Module IDs are stable and treated as opaque strings
 * - registry() must run before any require()
 * - require() must stay synchronous
 * - requireByHttp() must NOT execute code directly
 */
(function (GlobalConstructor, global, modules, entry) {
  // -------------------------------------------------------------------------
  // Module storage
  // -------------------------------------------------------------------------
  // __modules__:
  //   Source-of-truth registry populated only by the bundler or remote bundles.
  // __modulePointer__:
  //   Execution cache; a module is executed exactly once.
  // __asyncModulePointer__:
  //   Deduplication layer for remote loads.
  var __modules__ = {};
  var __modulePointer__ = {};
  var __asyncModulePointer__ = {};

  // -------------------------------------------------------------------------
  // CSS runtime compatibility layer
  // -------------------------------------------------------------------------
  /**
   * This polyfill exists solely to preserve a single execution path
   * for CSS modules across modern and legacy browsers.
   *
   * Contributors:
   * - Do NOT expand this into a full CSSOM polyfill
   * - Only APIs used by the runtime are implemented intentionally
   * - Breaking replaceSync semantics will break CSS module tests
   */
  (function (global) {
    if (
      typeof global.CSSStyleSheet === "function" &&
      "replaceSync" in global.CSSStyleSheet.prototype
    ) {
      return;
    }

    function CSSStyleSheet() {
      this._styleEl = document.createElement("style");
      this._styleEl.setAttribute("data-polyfilled", "true");

      (document.head || document.getElementsByTagName("head")[0])
        .appendChild(this._styleEl);
    }

    CSSStyleSheet.prototype.replaceSync = function (cssText) {
      if (this._styleEl.styleSheet) {
        this._styleEl.styleSheet.cssText = cssText || "";
      } else {
        this._styleEl.textContent = cssText || "";
      }
      return this;
    };

    CSSStyleSheet.prototype.replace = function (cssText) {
      var self = this;
      return new Promise(function (resolve) {
        self.replaceSync(cssText);
        resolve(self);
      });
    };

    /**
     * adoptedStyleSheets is treated as declarative state.
     * Setting it must fully replace previous styles.
     */
    function defineAdoptedStyleSheets(doc) {
      if (doc.adoptedStyleSheets !== undefined) return;

      var adopted = [];

      try {
        Object.defineProperty(doc, "adoptedStyleSheets", {
          get: function () {
            return adopted;
          },
          set: function (sheets) {
            // Clear previous state
            for (var i = 0; i < adopted.length; i++) {
              var old = adopted[i];
              if (old && old._styleEl?.parentNode) {
                old._styleEl.parentNode.removeChild(old._styleEl);
              }
            }

            adopted = sheets || [];

            // Apply new state
            for (var j = 0; j < adopted.length; j++) {
              if (adopted[j]?._styleEl) {
                (document.head || document.getElementsByTagName("head")[0])
                  .appendChild(adopted[j]._styleEl);
              }
            }
          }
        });
      } catch {
        // IE fallback: consistency over correctness
        doc.adoptedStyleSheets = adopted;
      }
    }

    defineAdoptedStyleSheets(document);
    global.CSSStyleSheet = CSSStyleSheet;
  })(global);

  // -------------------------------------------------------------------------
  // URL & ID utilities
  // -------------------------------------------------------------------------
  /**
   * These helpers intentionally avoid URL and Path APIs.
   * Reason:
   * - Must work in very old browsers
   * - Must not rely on bundler-time transforms
   */

  /**
   * Extracts the current host/base URL from window.location.
   * Required for constructing absolute URLs for remote module loading.
   */
  function getHostFromCurrentUrl() {
    var href = window.location.href;
    var clean = href.split(/[?#]/)[0];
    var parts = clean.split("/");
    var lastPart = parts[parts.length - 1];

    if (lastPart && lastPart.indexOf(".") > -1) {
      parts.pop(); // Remove filename part
      return parts.join("/");
    } else {
      var originMatch = clean.match(/^(https?:\/\/[^/]+)/i);
      return originMatch ? originMatch[1] : clean;
    }
  }

  // Extracts extension from a module ID string
  function getExt(id) {
    var parts = id.split(".");
    return parts.length > 1 ? "." + parts.pop() : "";
  }

  /**
   * Extension filtering is a safety boundary.
   * Contributors must update this list consciously.
   */
  function isSupportedExtension(ext) {
    return (
      ext === ".js"  ||
      ext === ".mjs" ||
      ext === ".json"||
      ext === ".css" ||
      ext === ".svg" ||
      ext === ".xml" ||
      ext === ".html"
    );
  }

  /**
   * Remote bundles are always JavaScript.
   * The original extension is semantic only.
   */
  function ensureJsExtension(outputFilePath) {
    var clean = outputFilePath.split(/[?#]/)[0];
    var parts = clean.split("/");
    var last = parts[parts.length - 1];

    if (last.indexOf(".") > -1) {
      last = last.replace(/\.[^.]+$/, ".js");
    } else {
      last = last + ".js";
    }
    parts[parts.length - 1] = last;
    return parts.join("/");
  }

  // -------------------------------------------------------------------------
  // registry()
  // -------------------------------------------------------------------------
  /**
   * registry() is write-once per module ID.
   *
   * Remote bundles rely on this behavior to safely register
   * themselves after execution.
   */
  function registry(modules) {
    for (var key in modules) {
      if (modules.hasOwnProperty(key) && !__modules__[key]) {
        __modules__[key] = modules[key];
      }
    }
  }

  // -------------------------------------------------------------------------
  // Async module loading
  // -------------------------------------------------------------------------
  /**
   * Remote loading is intentionally side-effect driven:
   * - Script execution triggers registry()
   * - Resolution depends on module execution completing
   *
   * Do NOT replace this with fetch() or dynamic import()
   * without updating the entire runtime contract.
   */
  function RequireAsynchronously(id, path, url) {
    var actualPath = url ? url + path : getHostFromCurrentUrl() + "/" + path;

    var scriptLoader = document.createElement("script");
    scriptLoader.setAttribute("src", ensureJsExtension(actualPath));

    var head = document.head || document.getElementsByTagName("head")[0];

    if (typeof Promise !== "undefined") {
      var $this = new Promise(function (resolve, reject) {
        scriptLoader.onload = function () {
          resolve(__modulePointer__[id].exports);
        };
        scriptLoader.onerror = function (err) {
          reject(err);
        };
      });

      head.appendChild(scriptLoader);
      return $this;
    }

    // Legacy browsers: minimal .then() and .catch() polyfill
    else {
      this.then = function (resolve) {
        scriptLoader.onload = function () {
          resolve(__modulePointer__[id].exports);
        };
        return this;
      };

      this["catch"] = function (reject) {
        scriptLoader.onerror = reject;
        return this;
      };

      head.appendChild(scriptLoader);
    }
  }

  // -------------------------------------------------------------------------
  // requireByHttp(): Wrapper for async module loading by identifier
  // -------------------------------------------------------------------------
  function requireByHttp(id, attributes) {
    if (!id) return;

    var ext = getExt(id);
    if (!isSupportedExtension(ext)) {
      return;
    }

    var moduleId = id;

    if (__asyncModulePointer__[moduleId]) {
      return __asyncModulePointer__[moduleId];
    }

    var modulePath = moduleId.split("::")[1];

    var moduleUrl = /^https?:\/\//.test(attributes.address)
      ? attributes.address.split(modulePath)[0]
      : null;

    var result = new RequireAsynchronously(moduleId, modulePath, moduleUrl);

    __asyncModulePointer__[moduleId] = result;

    return result;
  }

  // -------------------------------------------------------------------------
  // require()
  // -------------------------------------------------------------------------
  /**
   * Core invariant:
   * - require() is synchronous
   * - async modules must resolve to Promises externally
   */
  function require(id) {
    if (!id) return;

    var ext = getExt(id);
    if (!isSupportedExtension(ext)) {
      return;
    }

    if (__modulePointer__[id]) {
      return __modulePointer__[id].exports;
    }

    var moduleData = __modules__[id];
    if (!moduleData) {
      throw new Error("Module not found: " + id);
    }

    var fn = moduleData[0];
    var mapping = moduleData[1];

    function localRequire(key) {
      return require(mapping[key]);
    }

    function remoteRequire(key, attributes = {}) {
      attributes.address = key;
      return requireByHttp(mapping[key], attributes);
    }

    var module = { exports: {} };
    __modulePointer__[id] = module;

    fn(localRequire, module.exports, module, remoteRequire);

    return module.exports;
  }

  // Runtime bootstrap
  registry(modules); // Register bundled modules
  require(entry); // Execute entry module

  // -------------------------------------------------------------------------
  // Global runtime bridge
  // -------------------------------------------------------------------------
  /**
   * Exposes stable references to the active runtime instance.
   *
   * Purpose:
   * - Allow separately loaded bundles (via <script> over network)
   *   to register modules into the same runtime context
   * - Allow remote bundles to execute their own entry modules
   *   using the host application's require()
   *
   * Contract:
   * - "&registry" MUST point to the current module registry function
   * - "&require"  MUST point to the current synchronous require()
   *
   * Design notes for contributors:
   * - This is NOT a public API, but a runtime-level bridge
   * - Removing or renaming these keys will break remote bundles
   * - The function reference must remain stable across executions
   *
   * Typical usage from a remote bundle:
   *   global["*pointers"]("&registry")(remoteModules)
   *   global["*pointers"]("&require")(remoteEntry)
   */
  GlobalConstructor.prototype["*pointers"] = function (address) {
    if (address === "&registry") {
      return registry;
    } else if (address === "&require") {
      return require;
    }
    return null;
  };
})(
  typeof window !== "undefined" ? Window : this,
  typeof window !== "undefined" ? window : this,
  __INJECT_MODULES__,
  __INJECT_ENTRY__
);
