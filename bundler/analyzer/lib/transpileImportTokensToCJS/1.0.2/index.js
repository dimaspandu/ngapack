import getDestructureEndIndex from "../../utils/getDestructureEndIndex.js";
import getDynamicImportEndIndex from "../../utils/getDynamicImportEndIndex.js";
import getObjectLiteralsEndIndex from "../../utils/getObjectLiteralsEndIndex.js";

/**
 * transpileImportTokensToCJS(tokens, dynamicImportIdentifier)
 *
 * Main entry point for transforming ESM-style import tokens into
 * equivalent CommonJS constructs. This function operates directly
 * on token arrays rather than raw strings. The transformation is
 * intentionally lightweight and syntactic only. It does not evaluate
 * JavaScript semantics, perform scope analysis, or validate code
 * correctness beyond import-related grammar.
 *
 * Parameters:
 * - tokens (Array<Object>):
 *     The raw token stream representing the source file. This must
 *     already be normalized (e.g., whitespace/comments removed)
 *     before being passed to this function.
 *
 * - dynamicImportIdentifier (string):
 *     A string identifier that determines which runtime function is
 *     used to replace ESM `import()` expressions. Defaults to
 *     "requireByHttp". For example:
 *
 *         import("x")      →   requireByHttp("x")
 *
 *     This parameter allows consumers to provide their own dynamic
 *     loading mechanism, such as:
 *
 *         transpileImportTokensToCJS(tokens, "customAsyncRequire")
 *
 *     making the transformer adaptable to multiple runtime models.
 *
 * General workflow:
 * 1. Iterate through all tokens and attempt to match syntactic patterns
 *    for ESM imports. Supported patterns include:
 *       - default imports
 *       - named (destructured) imports
 *       - namespace imports
 *       - default + named combinations
 *       - default + namespace combinations
 *       - side-effect imports:   import "module";
 *       - dynamic imports:        import("module")
 *
 * 2. When a match is found, synthetic CJS tokens are emitted into
 *    bufferTokens while marking the original tokens as skipped.
 *
 * 3. Non-import tokens or tokens marked for skipping are passed through
 *    unchanged.
 *
 * Returned value:
 * An array of transformed tokens containing pure CommonJS equivalents
 * of the original import statements, suitable for final reconstruction
 * by a printer/stringifier.
 */
export default function transpileImportTokensToCJS(
  tokens,
  dynamicImportIdentifier = "requireByHttp"
) {

  /**
   * Remove tokens that have no semantic value for structural code
   * transformation. Whitespace, newlines, and comments are not needed
   * for recognizing import grammars and only add noise.
   *
   * Filtering at this stage makes pattern matching faster and simpler.
   */
  tokens = tokens.filter(
    t => t.type !== "newline" && t.type !== "whitespace" && t.type !== "comment"
  );

  // Stores all transformed output tokens.
  const bufferTokens = [];

  // This is currently unused but kept for compatibility with earlier versions.
  const importTokens = [];

  /**
   * skippedIndex maps numeric token indices to a flag.
   * When a transform consumes or replaces a set of tokens,
   * the originals are marked in skippedIndex so that the main
   * iteration loop does not emit them again.
   */
  const skippedIndex = {};

  // Helper for pushing the literal keyword "const".
  const pushConst = () => bufferTokens.push({ type: "keyword", value: "const" });

  // Helper for pushing a punctuation token.
  const pushPunct = val => bufferTokens.push({ type: "punctuator", value: val });

  /**
   * Main linear scan. Because tokens can be inserted by splice,
   * the stream changes during iteration. This implementation
   * intentionally does not adjust the loop index to track insertions
   * since they are placed after the current index and recognized
   * by future conditions safely.
   */
  for (let i = 0; i < tokens.length; i++) {
    const idx = i;
    const cur = tokens[idx];

    // Safe next-token accessor.
    const next = n => tokens[idx + n];

    // Determines whether a token is a semicolon punctuator.
    const isSemi = t => t && t.type === "punctuator" && t.value === ";";

    /**
     * Skip a semicolon artificially generated by the ESM syntax.
     * Many import forms may or may not have trailing semicolons.
     * When a semicolon exists but the transform already inserts one,
     * the original must be ignored to avoid duplication.
     */
    const skipIfSemi = pos => {
      if (isSemi(tokens[pos])) skippedIndex[pos] = 1;
    };

    /**
     * Skip an entire object literal following `assert` or `with`.
     * Example:
     *   import x from "y" assert { type: "json" };
     *
     * The object literal starts after "assert" or "with".
     * getObjectLiteralsEndIndex locates the closing "}".
     */
    const skipObjectLiteral = pos => {
      skippedIndex[pos] = 1;
      const endIndex = getObjectLiteralsEndIndex(tokens, pos + 1);
      for (let j = pos + 1; j <= endIndex; j++) skippedIndex[j] = 1;
      skipIfSemi(endIndex + 1);
    };

    // ===============================================================
    // IMPORT DEFAULT:  import Default from "module"
    // ===============================================================
    if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) && next(3) &&
      next(1).type === "identifier" &&
      next(2).type === "identifier" && next(2).value === "from" &&
      next(3).type === "string"
    ) {
      /**
       * Pattern recognized:
       *   import a from "b"
       *
       * Transform into:
       *   const a = require("b").default;
       */
      pushConst();

      next(2).type = "punctuator";
      next(2).value = "=";

      // Splice tokens to form: a = require("module").default;
      tokens.splice(idx + 3, 0, { type: "identifier", value: "require" });
      tokens.splice(idx + 4, 0, { type: "punctuator", value: "(" });
      tokens.splice(idx + 6, 0, { type: "punctuator", value: ")" });
      tokens.splice(idx + 7, 0, { type: "punctuator", value: "." });
      tokens.splice(idx + 8, 0, { type: "identifier", value: "default" });
      tokens.splice(idx + 9, 0, { type: "punctuator", value: ";" });

      const t10 = next(10);

      if (isSemi(t10)) skippedIndex[idx + 10] = 1;
      else if (t10 && (
        (t10.type === "identifier" && t10.value === "assert") ||
        (t10.type === "keyword" && t10.value === "with")
      )) {
        skipObjectLiteral(idx + 10);
      }
    }

    // ===============================================================
    // IMPORT DESTRUCTURING:  import { a, b } from "module"
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) && next(3) &&
      next(1).type === "punctuator" && next(1).value === "{" &&
      next(2).type === "identifier" &&
      (
        (next(3).type === "punctuator" && next(3).value === ",") ||
        (next(3).type === "identifier" && next(3).value === "as")
      )
    ) {
      /**
       * Pattern recognized:
       *   import { a, b, c } from "module"
       *
       * For each imported identifier, this produces:
       *   const a = require("module").a;
       *   const b = require("module").b;
       *   const c = require("module").c;
       *
       * Renamed bindings like:
       *   import { a as x }
       * become:
       *   const x = require("module").a;
       */
      const destructureEnd = getDestructureEndIndex(tokens, idx + 1);
      const modulePathIndex = destructureEnd + 2;
      const scopeEndIndex = destructureEnd + 3;
      const requireTokens = generateRequireTokens(tokens[modulePathIndex]);

      // Skip "}" and "from" and the string module path after generating constants.
      skippedIndex[destructureEnd + 1] = 1;
      skippedIndex[destructureEnd + 2] = 1;
      skipIfSemi(scopeEndIndex);

      // Walk through destructuring identifiers one by one.
      for (let j = idx + 1; j <= destructureEnd; j++) {
        skippedIndex[j] = 1;

        const tPrev = tokens[j - 1];
        const tCur = tokens[j];
        const tNext = tokens[j + 1];

        /**
         * Detect simple identifiers within the destructuring block.
         * Example patterns:
         *   { a, b, c }
         *   { a, b }
         */
        const isSimple =
          (tPrev.type === "punctuator" && tNext.type === "punctuator" &&
           ((tPrev.value === "," && tNext.value === ",") ||
            (tPrev.value === "{" && tNext.value === ",") ||
            (tPrev.value === "," && tNext.value === "}")));

        // Simple binding: a
        if (isSimple) {
          pushConst();
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct("=");
          bufferTokens.push(...requireTokens, { type: "punctuator", value: "." });
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct(";");
        }

        // Renamed binding: a as x
        else if (tNext.type === "identifier" && tNext.value === "as") {
          pushConst();
          bufferTokens.push({ type: tokens[j + 2].type, value: tokens[j + 2].value });
          pushPunct("=");
          bufferTokens.push(...requireTokens, { type: "punctuator", value: "." });
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct(";");
        }
      }
    }

    // ===============================================================
    // IMPORT DEFAULT + DESTRUCTURING:
    //   import a, { b, c } from "module"
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) && next(3) && next(4) && next(5) &&
      next(1).type === "identifier" &&
      next(2).type === "punctuator" && next(2).value === "," &&
      next(3).type === "punctuator" && next(3).value === "{" &&
      next(4).type === "identifier" &&
      (
        (next(5).type === "punctuator" && next(5).value === ",") ||
        (next(5).type === "identifier" && next(5).value === "as")
      )
    ) {
      /**
       * Pattern:
       *   import def, { a, b } from "module"
       *
       * Transforms into:
       *   const def = require("module").default;
       *   const a = require("module").a;
       *   const b = require("module").b;
       */
      const defId = next(1);
      const destructureEnd = getDestructureEndIndex(tokens, idx + 1);
      const modulePathIdx = destructureEnd + 2;
      const scopeEndIdx = destructureEnd + 3;
      const requireTokens = generateRequireTokens(tokens[modulePathIdx]);

      skippedIndex[idx + 1] = skippedIndex[idx + 2] = 1;

      // Generate the default binding.
      pushConst();
      bufferTokens.push({ type: defId.type, value: defId.value });
      pushPunct("=");
      bufferTokens.push(...requireTokens, { type: "punctuator", value: "." });
      bufferTokens.push({ type: "identifier", value: "default" });
      pushPunct(";");

      // Skip structural tokens following destructuring block.
      skippedIndex[destructureEnd + 1] = 1;
      skippedIndex[destructureEnd + 2] = 1;
      skipIfSemi(scopeEndIdx);

      // Handle destructured members in exactly the same way as earlier.
      for (let j = idx + 1; j <= destructureEnd; j++) {
        skippedIndex[j] = 1;

        const tPrev = tokens[j - 1];
        const tCur = tokens[j];
        const tNext = tokens[j + 1];

        const isSimple =
          (tPrev.type === "punctuator" && tNext.type === "punctuator" &&
           ((tPrev.value === "," && tNext.value === ",") ||
            (tPrev.value === "{" && tNext.value === ",") ||
            (tPrev.value === "," && tNext.value === "}")));

        if (isSimple) {
          pushConst();
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct("=");
          bufferTokens.push(...requireTokens, { type: "punctuator", value: "." });
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct(";");
        }

        else if (tNext.type === "identifier" && tNext.value === "as") {
          pushConst();
          bufferTokens.push({ type: tokens[j + 2].type, value: tokens[j + 2].value });
          pushPunct("=");
          bufferTokens.push(...requireTokens, { type: "punctuator", value: "." });
          bufferTokens.push({ type: tCur.type, value: tCur.value });
          pushPunct(";");
        }
      }
    }

    // ===============================================================
    // IMPORT * AS:  import * as X from "module"
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) && next(3) && next(4) && next(5) &&
      next(1).type === "punctuator" && next(1).value === "*" &&
      next(2).type === "identifier" && next(2).value === "as" &&
      next(3).type === "identifier" &&
      next(4).type === "identifier" && next(4).value === "from" &&
      next(5).type === "string"
    ) {
      /**
       * Pattern:
       *   import * as ns from "module"
       *
       * Transformation:
       *   const ns = require("module");
       */
      pushConst();
      skippedIndex[idx + 1] = skippedIndex[idx + 2] = 1;

      next(4).type = "punctuator";
      next(4).value = "=";

      tokens.splice(idx + 5, 0, { type: "identifier", value: "require" });
      tokens.splice(idx + 6, 0, { type: "punctuator", value: "(" });
      tokens.splice(idx + 8, 0, { type: "punctuator", value: ")" });
      tokens.splice(idx + 9, 0, { type: "punctuator", value: ";" });

      const t10 = next(10);
      if (isSemi(t10)) skippedIndex[idx + 10] = 1;
      else if (t10 && (t10.value === "assert" || t10.value === "with")) {
        skipObjectLiteral(idx + 10);
      }
    }

    // ===============================================================
    // IMPORT DEFAULT + * AS:
    //   import def, * as ns from "module"
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) && next(3) && next(4) && next(5) && next(6) && next(7) &&
      next(1).type === "identifier" &&
      next(2).type === "punctuator" && next(2).value === "," &&
      next(3).type === "punctuator" && next(3).value === "*" &&
      next(4).type === "identifier" && next(4).value === "as" &&
      next(5).type === "identifier" &&
      next(6).type === "identifier" && next(6).value === "from" &&
      next(7).type === "string"
    ) {
      /**
       * Pattern:
       *   import def, * as ns from "module"
       *
       * Transformation:
       *   const ns = require("module");
       *   const def = ns.default;
       */
      const requireTokens = generateRequireTokens(next(7));

      for (let k = 1; k <= 7; k++) skippedIndex[idx + k] = 1;

      // Namespace
      pushConst();
      bufferTokens.push({ type: next(5).type, value: next(5).value });
      pushPunct("=");
      bufferTokens.push(...requireTokens);
      pushPunct(";");

      // Default through namespace
      pushConst();
      bufferTokens.push({ type: next(1).type, value: next(1).value });
      pushPunct("=");
      bufferTokens.push({ type: next(5).type, value: next(5).value });
      pushPunct(".");
      bufferTokens.push({ type: "identifier", value: "default" });
      pushPunct(";");

      const t8 = next(8);
      if (isSemi(t8)) skippedIndex[idx + 8] = 1;
      else if (t8 && (t8.value === "assert" || t8.value === "with")) {
        skipObjectLiteral(idx + 8);
      }
    }

    // ===============================================================
    // BARE IMPORT:  import "module"
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) &&
      next(1).type === "string"
    ) {
      /**
       * Pattern:
       *   import "module"
       *
       * Transformation:
       *   require("module");
       *
       * There is no assigned binding, so a pure side-effect require
       * is emitted.
       */
      bufferTokens.push({ type: "identifier", value: "require" });
      tokens.splice(idx + 1, 0, { type: "punctuator", value: "(" });
      tokens.splice(idx + 3, 0, { type: "punctuator", value: ")" });
      tokens.splice(idx + 4, 0, { type: "punctuator", value: ";" });

      const t5 = next(5);

      if (isSemi(t5)) skippedIndex[idx + 5] = 1;
      else if (t5 && (t5.value === "assert" || t5.value === "with")) {
        skipObjectLiteral(idx + 5);
      }
    }

    // ===============================================================
    // DYNAMIC IMPORT:  import("module")
    // ===============================================================
    else if (
      cur.type === "keyword" && cur.value === "import" &&
      next(1) && next(2) &&
      next(1).type === "punctuator" && next(1).value === "(" &&
      (next(2).type === "string" ||
       (next(2).type !== "string" && next(2).type.startsWith("template")))
    ) {
      /**
       * Pattern:
       *   import("module")
       *
       * Represents a dynamic import expression. Since this transformer does
       * not attempt to preserve native ESM asynchronous semantics or perform
       * module loader resolution, it rewrites the expression into a call to
       * the function defined by `dynamicImportIdentifier`.
       *
       * Example rewrite (default behavior):
       *
       *   import("module")
       *       → requireByHttp("module")
       *
       * If the caller provides a different identifier:
       *
       *   transpileImportTokensToCJS(tokens, "asyncLoader")
       *
       * then:
       *
       *   import("module")
       *       → asyncLoader("module")
       *
       * The target function is assumed to be provided by the surrounding
       * runtime environment and must behave as the consumer expects.
       */
      bufferTokens.push({ type: "identifier", value: dynamicImportIdentifier });

      // Find end of dynamic import expression including nested parentheses.
      const endIndex = getDynamicImportEndIndex(tokens, idx);

      // Ensure trailing semicolon.
      if (!isSemi(tokens[endIndex])) {
        tokens.splice(endIndex + 1, 0, { type: "punctuator", value: ";" });
      }
    }

    // ===============================================================
    // DEFAULT: copy token if not skipped by previous rules.
    // ===============================================================
    else if (!skippedIndex[idx]) {
      bufferTokens.push({ type: cur.type, value: cur.value });
    }
  }

  return [...bufferTokens, ...importTokens];
}

/**
 * generateRequireTokens(modulePathToken)
 *
 * Helper that constructs the minimal token sequence for:
 *   require("<module>")
 *
 * Returns an array of tokens. The caller is responsible for
 * appending semicolons or additional property accesses.
 */
function generateRequireTokens(modulePathToken) {
  return [
    { type: "identifier", value: "require" },
    { type: "punctuator", value: "(" },
    modulePathToken,
    { type: "punctuator", value: ")" },
  ];
}
